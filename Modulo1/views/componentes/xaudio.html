<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="stylesheet" href="../../assets/css/reproductor-iframe.css" />
  <title>Audio Player (componente)</title>
  <meta name="robots" content="noindex">
  <style>
    /* Pequeño ajuste para garantizar la visibilidad */
    .audio-player-container.expanded .expanded-controls {
      display: flex;
      opacity: 1;
      transform: translateX(0);
    }
    
    /* --- ESTILOS PARA EL ESPECTRO --- */
    /* El contenedor principal necesita ser relativo y ocultar el desbordamiento
       para que el canvas con esquinas redondeadas se vea bien. */
    .audio-player-container {
        position: relative;
        overflow: hidden; /* Importante para los bordes redondeados */
    }
    
    #audioSpectrum {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* Asegura que el canvas esté detrás de TODOS los demás elementos */
        z-index: -1;
        pointer-events: none; /
    }

  </style>
</head>
<body>
  <div class="audio-control-wrapper">
    <div class="audio-player-container" id="audioContainer" tabindex="0" aria-label="Reproductor de audio">
      <canvas id="audioSpectrum"></canvas>

      <div class="expand-indicators" id="expandIndicators" title="Mostrar controles">
        <div class="expand-dot"></div>
        <div class="expand-dot"></div>
        <div class="expand-dot"></div>
      </div>

      <button class="play-pause-btn" id="playPauseBtn" aria-pressed="false" title="Reproducir / Pausar">
        <svg id="playIcon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z" /></svg>
        <svg id="pauseIcon" viewBox="0 0 24 24" style="display: none"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" /></svg>
      </button>

      <div class="expanded-controls" id="expandedControls">
        <div class="controls-column">
          <div class="progress-container">
            <div class="progress-bar" id="progressBar" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
              <div class="progress-fill" id="progressFill">
                <div class="progress-thumb" id="progressThumb"></div>
              </div>
            </div>
            <div class="time-labels" style="display:none;">
              <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
            </div>
          </div>
          <div class="volume-control">
            <button class="volume-btn" id="volumeToggle" title="Silenciar / Restaurar volumen">
              <svg id="volumeIcon" viewBox="0 0 24 24"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z" /></svg>
              <svg id="muteIcon" viewBox="0 0 24 24" style="display: none"><path d="M16.5 12c0-1.77-1.02-3.29-2.5-4.03v2.21l2.45 2.45c.03-.2.05-.41.05-.63zm2.5 0c0 .94-.2 1.82-.54 2.64l1.51 1.51C20.63 14.91 21 13.5 21 12c0-4.28-2.99-7.86-7-8.77v2.06c2.89.86 5 3.54 5 6.71zM4.27 3L3 4.27 7.73 9H3v6h4l5 5v-6.73l4.25 4.25c-.67.52-1.42.93-2.25 1.18v2.06c1.38-.31 2.63-.95 3.69-1.81L19.73 21 21 19.73l-9-9L4.27 3zM12 4L9.91 6.09 12 8.18V4z" /></svg>
            </button>
            <div class="volume-slider" id="volumeSlider" role="slider" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100" title="Volumen">
              <div class="volume-fill" id="volumeFill"></div>
            </div>
          </div>
        </div>

        <button class="close-btn" id="closeBtn" title="Cerrar reproductor">
          <svg viewBox="0 0 24 24"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" /></svg>
        </button>
      </div>

      <audio id="audioPlayer" preload="metadata" controlslist="nodownload" playsinline crossorigin="anonymous">
        <source id="audioSource" src="" type="audio/wav" />
        Tu navegador no soporta el elemento de audio.
      </audio>
    </div>
  </div>
  <script>
    (function () {
    // --- SELECCIÓN DE ELEMENTOS ---
    const audio = document.getElementById('audioPlayer');
    const audioSource = document.getElementById('audioSource');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const playIcon = document.getElementById('playIcon');
    const pauseIcon = document.getElementById('pauseIcon');
    const volumeToggle = document.getElementById('volumeToggle');
    const volumeIcon = document.getElementById('volumeIcon');
    const muteIcon = document.getElementById('muteIcon');
    const progressBar = document.getElementById('progressBar');
    const progressFill = document.getElementById('progressFill');
    const volumeSlider = document.getElementById('volumeSlider');
    const volumeFill = document.getElementById('volumeFill');
    const audioContainer = document.getElementById('audioContainer');
    const expandIndicators = document.getElementById('expandIndicators');
    const closeBtn = document.getElementById('closeBtn');
    
    // --- ELEMENTOS Y CONFIGURACIÓN DEL ESPECTRO ---
    const canvas = document.getElementById('audioSpectrum');
    // Ajustar el tamaño del canvas para que coincida con su contenedor
    canvas.width = audioContainer.clientWidth;
    canvas.height = audioContainer.clientHeight;
    const canvasCtx = canvas.getContext('2d');

    let isDraggingProgress = false;
    let isDraggingVolume = false;
    let lastVolume = 1;
    
    // --- VARIABLES DE WEB AUDIO API ---
    let audioContext;
    let analyser;
    let sourceNode;
    let dataArray;
    let bufferLength;
    let isAudioContextSetup = false;
    let animationFrameId;

    // --- LÓGICA DE RESOLUCIÓN DE RUTA DE AUDIO ---
    function getAudioFromIframeAttribute() {
        try {
            const iframeElement = window.frameElement;
            if (iframeElement && iframeElement.dataset && iframeElement.dataset.audio) {
                return iframeElement.dataset.audio.trim();
            }
        } catch (e) {
            console.warn('No se pudo acceder a los atributos del iframe.');
        }
        return null;
    }

    function getAudioFromQuery() {
        try {
            const params = new URLSearchParams(window.location.search);
            const audioParam = params.get('audio');
            return audioParam ? audioParam.trim() : null;
        } catch (e) { return null; }
    }
    
    function resolveRelativePath(path) {
        if (!path || /^(https?:)?\/\//i.test(path) || path.startsWith('/')) {
            return path;
        }
        try {
            return new URL(path, window.parent.location.href).href;
        } catch (e) { return path; }
    }
    
    function determineAudioSrc() {
        const fromIframeAttr = getAudioFromIframeAttribute();
        if (fromIframeAttr) return resolveRelativePath(fromIframeAttr);

        const fromQuery = getAudioFromQuery();
        if (fromQuery) return resolveRelativePath(fromQuery);
        
        return resolveRelativePath('../assets/audio/M1_pagina1.wav');
    }

    // --- INICIALIZACIÓN Y AUTOPLAY ---
    function setAudioSrc() {
        const resolvedSrc = determineAudioSrc();
        if (audioSource.src !== resolvedSrc) {
            audioSource.src = resolvedSrc;
            audio.load();
        }
    }

    function tryAutoplay() {
        audio.play().catch(() => {
            console.log("Autoplay bloqueado. Se requiere interacción del usuario.");
        });
    }

    setAudioSrc();
    audio.addEventListener('canplay', tryAutoplay, { once: true });
    
    // --- LÓGICA DEL ESPECTRO ---
    function setupAudioContext() {
        if (isAudioContextSetup) return;
        
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioContext.createAnalyser();
        sourceNode = audioContext.createMediaElementSource(audio);
        
        sourceNode.connect(analyser);
        analyser.connect(audioContext.destination);
        
        analyser.fftSize = 256;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        
        isAudioContextSetup = true;
    }

    // --- FUNCIÓN DE DIBUJO DEL ESPECTRO (MODIFICADA) ---
    function drawSpectrum() {
        animationFrameId = requestAnimationFrame(drawSpectrum);
        analyser.getByteFrequencyData(dataArray);

        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        
        const barWidth = (canvas.width / bufferLength) * 1.5;
        let x = 0;

        // Crear un gradiente para las barras
        const gradient = canvasCtx.createLinearGradient(0, 0, 0, canvas.height);
        gradient.addColorStop(0, 'rgba(0, 255, 255, 0.7)'); // Color superior
        gradient.addColorStop(1, 'rgba(255, 0, 150, 0.5)'); // Color inferior
        canvasCtx.fillStyle = gradient;

        for (let i = 0; i < bufferLength; i++) {
            // Escalar la altura de la barra. Se divide por 2 para el efecto espejo.
            const barHeight = (dataArray[i] / 255) * (canvas.height / 2);

            // Dibujar la barra superior (crece hacia abajo desde el borde superior)
            canvasCtx.fillRect(x, 0, barWidth, barHeight);

            // Dibujar la barra inferior (crece hacia arriba desde el borde inferior)
            canvasCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
            
            x += barWidth + 1; // +1 para dejar un pequeño espacio entre barras
        }
    }


    // --- LÓGICA DE EXPANSIÓN/CONTRACCIÓN ---
    function expandPlayer() {
        if (!audioContainer.classList.contains('expanded')) {
            audioContainer.classList.add('expanded');
        }
    }

    function collapsePlayer() {
        if (audioContainer.classList.contains('expanded')) {
            audioContainer.classList.remove('expanded');
        }
    }

    audioContainer.addEventListener('click', (e) => {
        if (e.target === audioContainer || e.target.closest('.expand-indicators')) {
            expandPlayer();
        }
    });

    closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        collapsePlayer();
        audio.pause();
    });

    // --- LÓGICA DEL REPRODUCTOR (PLAY/PAUSE, PROGRESO, VOLUMEN) ---
    function updatePlayState() {
        const isPlaying = !audio.paused;
        playIcon.style.display = isPlaying ? 'none' : 'block';
        pauseIcon.style.display = isPlaying ? 'block' : 'none';
        playPauseBtn.setAttribute('aria-pressed', String(isPlaying));
        if (isPlaying) {
            playPauseBtn.classList.add('playing');
        } else {
            playPauseBtn.classList.remove('playing');
        }
    }

    playPauseBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        // <<< CAMBIO: Se elimina la inicialización del AudioContext de aquí.
        if (audio.paused) {
            // La lógica para reanudar el contexto ahora está en el evento 'play'
            audio.play();
        } else {
            audio.pause();
        }
    });
    
    // <<< CAMBIO CLAVE: Lógica de activación del espectro centralizada aquí.
    audio.addEventListener('play', () => {
        updatePlayState();
        
        // 1. Si el AudioContext no está configurado, lo configuramos ahora.
        if (!isAudioContextSetup) {
            setupAudioContext();
        }

        // 2. Si el contexto existe pero está "suspendido" (común en autoplay), lo reanudamos.
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // 3. Iniciamos la animación del espectro.
        drawSpectrum();
    });
    
    audio.addEventListener('pause', () => {
        updatePlayState();
        cancelAnimationFrame(animationFrameId);
        // Opcional: limpiar el canvas al pausar
        // canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    });
    audio.addEventListener('ended', () => {
        updatePlayState();
        cancelAnimationFrame(animationFrameId);
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
    });

    audio.addEventListener('timeupdate', () => {
        if (!isDraggingProgress && audio.duration) {
            const pct = (audio.currentTime / audio.duration) * 100;
            progressFill.style.width = pct + '%';
            progressBar.setAttribute('aria-valuenow', String(Math.floor(pct)));
        }
    });

    function seekFromEvent(e) {
        if (!audio.duration) return;
        const rect = progressBar.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        audio.currentTime = pct * audio.duration;
        progressFill.style.width = (pct * 100) + '%';
    }

    function setupDrag(element, onDrag, onStart, onEnd) {
        const onMouseMove = (moveEvent) => onDrag(moveEvent);
        const onMouseUp = () => {
            if (onEnd) onEnd();
            window.removeEventListener('mousemove', onMouseMove);
            window.removeEventListener('mouseup', onMouseUp);
        };
        element.addEventListener('mousedown', (e) => {
            if (onStart) onStart(e);
            onDrag(e);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('mouseup', onMouseUp);
        });
    }

    setupDrag(progressBar, seekFromEvent, () => isDraggingProgress = true, () => isDraggingProgress = false);

    function setVolumeFromEvent(e) {
        const rect = volumeSlider.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const pct = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
        audio.volume = pct;
        audio.muted = false;
    }

    audio.addEventListener('volumechange', () => {
        const isMuted = audio.muted || audio.volume === 0;
        volumeFill.style.width = (isMuted ? 0 : audio.volume * 100) + '%';
        volumeIcon.style.display = isMuted ? 'none' : 'block';
        muteIcon.style.display = isMuted ? 'block' : 'none';
        if (!isMuted) lastVolume = audio.volume;
    });

    setupDrag(volumeSlider, setVolumeFromEvent, () => isDraggingVolume = true, () => isDraggingVolume = false);

    volumeToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        audio.muted = !audio.muted;
        if (!audio.muted && audio.volume === 0) {
            audio.volume = lastVolume > 0.05 ? lastVolume : 1;
        }
    });

    audio.addEventListener('ended', () => {
        console.log("audio-terminado");
        window.parent.postMessage({ type: 'audio-ended' }, '*');
        
    });

    // Estado inicial
    audio.volume = 1;
    lastVolume = 1;
    volumeFill.style.width = '100%';
    })();
  </script>
</body>
</html>